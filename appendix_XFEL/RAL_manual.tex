%
%  RAL XFEL FEE CCC/ASIC interface manual
%
%  Created by Sam Cook on Mon 28 Jan 2013
%
%  Copyright (c) 2013 RAL. All rights reserved.
%
\documentclass[]{article}

% Use utf-8 encoding for foreign characters
\usepackage[utf8]{inputenc}

% Setup for fullpage use
\usepackage{fullpage}

% Uncomment some of the following if you use the features
%
% Running Headers and footers
%\usepackage{fancyhdr}

% Multipart figures
%\usepackage{subfigure}

% Multirow tables
\usepackage {multirow}

% More symbols
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}

% Surround parts of graphics with box
% \usepackage{boxedminipage}

% Package for including code in the document
\usepackage{listings}

% If you want to generate a toc for each chapter (use with book)
\usepackage{minitoc}

% This is now the recommended way for checking for PDFLaTeX:
\usepackage{ifpdf}

% Add a bit of extra height to tables so '\hlines' don't look crap
\usepackage{array}
\setlength{\extrarowheight}{1.5pt}

% Create tables of a defined total width with wrapped columns
\usepackage{tabulary}
% wan to get ditto mark
\usepackage[T1]{fontenc}
\newcommand*{\dittostraight}{---\textquotedbl---} % available in T1 encoding
%\newif\ifpdf
%\ifx\pdfoutput\undefined
%\pdffalse % we are not running PDFLaTeX
%\else
%\pdfoutput=1 % we are running PDFLaTeX
%\pdftrue
%\fi

\ifpdf
\usepackage[pdftex]{graphicx}
\else
\usepackage{graphicx}
\fi
\title{LPD CCC/ASIC interface}
\author{ Sam Cook }

\date{\today}

\begin{document}

	\ifpdf
	\DeclareGraphicsExtensions{.pdf, .jpg, .tif}
	\else
	\DeclareGraphicsExtensions{.eps, .jpg}
	\fi

	\maketitle

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\begin{abstract}
		Design and operation of the Clock and Control Card (CCC)/Large Pixel Detector (LPD) ASIC interface for the Eu-XFEL.
	\end{abstract}
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Introduction} % (fold)
	\label{sec:introduction}
	%
	% TODO add notes on typography (e.g. CAPS for states etc.)
	% 
	
	\begin{table}
		\begin{center}
			\begin{tabular}{c|c}
				Line & Notes \\
				\hline
				CLK    & 99.31~MHz system clock \\
				CMD    & Fast command signals (START, STOP etc.) \\
				VETO   & Veto/no-veto \\
				STATUS & Return line from the ASIC to the CCC \\
			\end{tabular}
		\end{center}
		\caption{Clock and control card signal specification}
		\label{tab:ccc_spec}
	\end{table}

	% section introduction (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Receiver} % (fold)
	\label{sec:receiver}
	As stated in the introduction there are 5 signals that are sent by the CCC, these are transmitted on two lines: the fast command and the veto. In addition to these two command lines there are the clock and status lines. The clock carries the derived fast clock (normally 99~MHz) which is synchronised to the slow machine clock (normally 4.5~MHz) which is distributed by the timing receiver. The status line is currently proposed to return the clock from the ASIC to indicate presence. The full list of commands and payloads can be seen in table~\ref{tab:ccc_commands}.
	
	\begin{table}
		\begin{center}
			\begin{tabulary}{\textwidth}{c | c | c | C | l}
				Line & Command & Value & Payload & Description \\
				\hline
				\multirow{5}{*}{Control} &
				  START & 1100 & Train ID (32b),bunch pattern ID (8b), checksum (8b) & Signals the start of the train \\
				& STOP  & 1010 & none                                                & Signals end of the train \\
				& RESET & 1001 & none                                                & Reset the front end and ASIC \\
				\hline
				
				\multirow{2}{*}{Veto} & VETO   & 110 & \multirow{2}{*}{Bunch ID (8b)} & Veto this bunch \\
				                      & NOVETO & 101 &                                & Record this bunch \\
			\end{tabulary}
		\end{center}
		\caption{Command definitions for the fast and veto lines from the CCC, see \cite{CCC SPECIFICATION} for more details.}
		\label{tab:ccc_commands}
	\end{table}
	
	The receiver module is split into two state machines, one to handle each of the two command lines as seen in figure~\ref{fig:rx_block}. The blocks have similar designs although the command receiver block is slightly more complex to cope with the multiple signals. 
	\begin{figure}[htbp] 
		\centering
		\includegraphics[width=\textwidth]{images/pdfs/rx_block.pdf}
		\caption{Block diagram of the receiver block.}
		\label{fig:rx_block}
	\end{figure}
	
	The designs uses strobess to signal which type of command has been received and buses to hold the ID information. The ID-buses (train, bunch pattern, checksum and bunch) are cleared at the start of the next command, this means that the data is available when ever it is needed.
	
	Both of blocks use a simple state machine design that can be summarised as: `IDLE \( \rightarrow \) LOG\_COMMAND \( \rightarrow \) STROBE\_COMMAND \( \rightarrow \) [LOG\_PAYLOAD \( \rightarrow \)] IDLE'. For both command and veto lines the state machine is triggered by the line going high. The stream is de-serialised by passing the serial commands to a shift register once a command is matched then the appropriate strobes is set. If the command has an attached payload then that is passed to a shift register until the appropriate number of payload bits have been received when they are written to a bus and the machine returns to `IDLE'.
	\subsection{Interface} % (fold)
	\label{sub:rx_interface}
	The top level interface for the receiver block is shown in table~\ref{tab:rx_interface}. 
	\begin{table}
		\begin{center}
			\begin{tabulary}{\textwidth}{l|c|c|L}
				Name & Direction & Type & Description \\
				\hline
				START\_WORD            &  &  std\_logic\_vector (3:0) & Default serial command: 1100\\
				STOP\_WORD             &  &  std\_logic\_vector (3:0) & Default serial command: 1010         \\
				RESET\_WORD            &  &  std\_logic\_vector (3:0) & Default serial command: 1001         \\
				VETO\_WORD             &  &  std\_logic\_vector (2:0) & Default serial command: 110          \\
				NO\_VETO\_WORD         &  &  std\_logic\_vector (2:0) & Default serial command: 101          \\
				BUNCH\_ID\_LENGTH      &  &  integer                  & Expected bunch ID length (default:12)\\
				TRAIN\_ID\_LENGTH      &  &  integer                  & Expected train ID length (default:32)\\
				CHECKSUM\_LENGTH       &  &  integer                  & Expected checksum length (default:8) \\
				BUNCH\_PATTERN\_LENGTH & \multirow{-9}{*}[11.5pt]{Generic} &  integer                  & Expected bunch pattern ID length (default:8) \\
				\hline
				clk          & \multirow{4}{*}{in}  & std\_logic                & CCC clock \\
				rst          &   & std\_logic                & FEE internal reset              \\
				cmd\_i       &   & std\_logic                & Fast command line from CCC      \\
				veto\_i      &   & std\_logic                & Fast veto line from CCC         \\
				\hline
				start\_o     & \multirow{8}{*}{out} & std\_logic                & Start signal to transmitter     \\
				stop\_o      &  & std\_logic                & Stop signal to transmitter      \\
				rst\_o       &  & std\_logic                & Reset signal for transmitter    \\
				veto\_o      &  & std\_logic                & Veto to trigger veto filter     \\
				no\_veto\_o  &  & std\_logic                & No veto to trigger veto filter  \\
				bunch\_p\_o  &  & std\_logic\_vector (7:0)  & Bunch pattern ID to veto filter \\
				bunch\_id\_o &  & std\_logic\_vector (7:0)  & Bunch ID to veto filter         \\
				train\_o     &  & std\_logic\_vector (31:0) & Train ID to veto filter         \\
			\end{tabulary}
		\end{center}
		\caption{Top level interface of the receiver block.}
		\label{tab:rx_interface}
	\end{table}
	% subsection interface (end)
	\subsection{Implementation} % (fold)
	\label{sub:rx_implementation}

	\begin{figure}[htbp]
		\centering
		\includegraphics[width=\textwidth]{images/pdfs/cmd_rx_flow.pdf}
		\caption{Flow diagram of the command receiver. The serial signals are read and flags set as required. The `START' payload (i.e. train ID, bunch pattern ID and checksum) are stored and remain available until cmd\_i next goes high (i.e. the start of the next command).}
		\label{fig:cmd_rx_flow}
	\end{figure}
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale=1]{images/pdfs/veto_rx_flow.pdf}
		\caption{Flow diagram of the veto receiver block. This de-serialises and splits the veto signals into the command and its payload, the bunch id.}
		\label{fig:veto_rx_flow}
	\end{figure}

	The individual flow diagrams can be seen in figures \ref{fig:cmd_rx_flow} and \ref{fig:veto_rx_flow}. Whilst at an abstract level the two systems are very similar the actual implementations are quite different as will be seen.
	
	The majority of the implementation is carried out using shift registers, one for each type of word to be recorded, i.e. command or payload. The command receiver there are 5 states and 4 registers: COMMAND, TRAIN, BUNCH\_PATTERN, CHECKSUM and IDLE, which does not have a corresponding register. The veto receiver only has 2 states with one register for each: COMMAND and BUNCH\_ID. 
	
	
	% subsection implementation (end)
	% section receiver (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Veto Filter} % (fold)
	\label{sec:veto_filter}
	\subsection{Interface} % (fold)
	\label{sub:veto_interface}
	
	\begin{table}
		\begin{center}
			\begin{tabulary}{\textwidth}{l|c|c|L}
				Name & Direction & Type & Description \\
				\hline 
				WORD\_LENGTH               & \multirow{4}{*}[-23pt]{Generic} 
										  	 & integer                   & Length of ASIC command word (default: 22).           \\
				MAX\_NVETOS                & & integer                   & Number of n\_vetos we can send (default: 512).       \\
				N\_BUNCHES                 & & integer                   & Maximum number of bunches in a train (default: 3072).\\
				PATTERN\_REG\_(0:9)\_RESET & & std\_logic\_vector (31:0) & Reset values for the pattern register (default: see~\ref{sub:veto_registers}). \\
				\hline
				clk                & \multirow{10}{*}[-5.75pt]{in}  
									 & std\_logic                & CCC clock.          \\
				rst                & & std\_logic                & Internal FEE reset.                             \\
				veto\_i            & & std\_logic                &                                                 \\
				nveto\_i           & & std\_logic                &                                                 \\
				start\_i           & & std\_logic                &                                                 \\
				stop\_i            & & std\_logic                &                                                 \\
				veto\_start        & & std\_logic                & Delayed start signal to coincide with vetos.    \\
				bunch\_id          & & std\_logic\_vector (11:0) & Not actually used.                              \\
				train\_id          & & std\_logic\_vector (31:0) & Added to the local link header.                 \\
				bunch\_pattern\_id & & std\_logic\_vector (7:0)  & Used to select the veto pattern.                \\
				\hline   
				veto\_to\_tx       & \multirow{2}{*}[-11.5pt]{out} 
				                      & std\_logic                & Combined pattern and veto decision.             \\
				nvetos\_sent       &  & std\_logic\_vector (8:0)  & Need to know how much to read from the ASIC.    \\
				\hline
				pattern\_bram\_rdma     & \multirow{3}{*}[-23pt]{interface} 
				                           & RDMA & Interface to the pattern block RAM, address mask: 0x000003FF \\
				pattern\_id\_reg\_rdma  &  & RDMA & Interface to the pattern id/BRAM offset registers, mask: 0x0000000F. \\
				ll                      &  & LocalLink & Interface to the veto log FIFO, uses a 256b data bus. \\
			\end{tabulary}
		\end{center}
		\caption{Top level interface for the veto filter.}
		\label{label}
	\end{table}
	% subsection veto_interface (end)
	\subsection{Registers} % (fold)
	\label{sub:veto_registers}
	In the veto filter there are two blocks, the pattern ID registers and pattern BRAM, both accessed via a dedicated RDMA interface and the veto log which is accessed via local link (see appendices~\ref{sec:rdma_interface} and~\ref{sec:local_link_interface}). 
	\subsubsection{Pattern BRAM} % (fold)
	\label{sub:pattern_bram}
	The pattern BRAM holds the pre-defined veto patterns. These are combined with the fast veto line to decide whether or not to veto a bunch (i.e. a bunch can be vetoed by either the pattern \emph{or} the veto line). Each pattern consists of a bit for each bunch in a train (it is assumed that there will be \( < \)3072 bunches in each train). If the bit is `1' then the bunch will be vetoed, otherwise it is dependant on the veto line.
	% TODO Add an assumptions section to introduction e.g. bunches/train, word length etc?	
	
	It is assumed that no more than 10 patterns will be needed in normal operation so the BRAM is configured as 1024\( \times  \)32b words. This means that for a 3072 bunch train 96 words need to be defined for each pattern. The pattern is applied in a monotonically increasing manner, the veto bits are applied 0 to 31 and words are read from offset\( + 0 \) to offset\( + 96 \) (assuming 3072 bunches per train and hence 96 words). 
	

	% subsection pattern_bram (end)
	\subsubsection{Pattern ID registers} % (fold)
	\label{sub:pattern_id_registers}
	The pattern ID registers map IDs to their appropriate offset within the BRAM. The specifications do not define the number of patterns needed during normal operation but it is assumed to be (\( < \)10); there are therefore 10 registers given to providing the required mapping one register per bunch pattern is used. The value of each register must be of the format:
	\begin{align} \label{fmt:pattern_id}
		<\text{PATTERN\_ID } 31:24>\ldots<\text{BRAM offset } 9:0> 
	\end{align}
	Default values for the register are given in table~\ref{tab:default_pattern_id_reg}, these default values are set via generics at the top level and can be changed there as required. The defaults assume that the patterns are all unique with no overlap, as such each delimitates 96\( \times \)32b words i.e. 3072 bunches. If there is an intersection between the end of one pattern and the start of another then setting the offset to the beginning of the common section should work as expected.
	\begin{table}
		\begin{center}
		\begin{tabular}{c|c|c|c}
			Register & Value      & Pattern ID & Offset \\
			\hline
			0x1      & 0x01000000 & 0x1        & 0x000  \\ 
			0x2      & 0x02000060 & 0x2        & 0x060  \\  
			0x3      & 0x030000C0 & 0x3        & 0x0C0  \\ 
			0x4      & 0x04000120 & 0x4        & 0x120  \\ 
			0x5      & 0x05000180 & 0x5        & 0x180  \\ 
			0x6      & 0x060001E0 & 0x6        & 0x1E0  \\ 
			0x7      & 0x07000240 & 0x7        & 0x240  \\ 
			0x8      & 0x080002A0 & 0x8        & 0x2A0  \\ 
			0x9      & 0x09000300 & 0x9        & 0x300  \\ 
			0xA      & 0x0A000360 & 0xA        & 0x360  \\ 
		\end{tabular}
		\end{center}
		\caption{Default reset values for pattern ID registers.}
		\label{tab:default_pattern_id_reg}
	\end{table}
	% subsubsection pattern_id_registers (end)
	% subsection veto_registers (end)
	\subsection{Implementation} % (fold)
	\label{sub:veto_implementation}
	
	% subsection veto_implementation (end)
	% section veto_filter (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Transmitter} % (fold)
	\label{sec:transmitter}
	
	\subsection{Interface} % (fold)
	\label{sub:tx_interface}
	
	\begin{table}
		\begin{center}
		\begin{tabulary}{\textwidth}{l | c | c | L}
			Name & Direction & Type & Description \\
			\hline
			WORD\_LENGTH          & & integer                   &  Default: 22;                                         \\
			N\_BUNCHES            & & integer                   &  Default: 3072;                                       \\
			CTRL\_REG\_RESET      & & std\_logic\_vector (31:0) &  Register resets, see section~\ref{sub:tx_registers}. \\
			START\_OFF\_RESET     & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			START\_NW\_RESET      & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			STOP\_OFF\_RESET      & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			STOP\_NW\_RESET       & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			RESET\_OFF\_RESET     & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			RESET\_NW\_RESET      & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			VETO\_WORD\_RESET     & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			NVETO\_WORD\_RESET    & & std\_logic\_vector (31:0) &  \dittostraight                                       \\ 
			% TODO Add a dedicated section for signal flags? 
			RSYNC\_SIG            & & std\_logic\_vector (31:0) & Flag that the RSYNC command has been sent.                 \\
			READOUT\_SIG          & & std\_logic\_vector (31:0) & Flag that the READOUT command has been sent.               \\
			DOWNSCALE\_SIG        & & std\_logic\_vector (31:0) & Flag to start the downscaler (either internal or external).\\
			DOWNSCALER\_STOP\_SIG & & std\_logic\_vector (31:0) & Flag to stop the downscaler.                               \\
			DOWNSCALE\_FACTOR     & \multirow{-16}{*}[11.5pt]{Generic} % Avoids extra newline at top
									& integer                   & Factor for the internal downscaler, default: 100.          \\
			\hline
			clk   & \multirow{6}{*}{In} 
					 & std\_logic & The CCC clock. \\
			rst   &  & std\_logic & FEE reset. \\
			start &  & std\_logic & \multirow{3}{*}{} \\
			stop  &  & std\_logic &  \\
			reset &  & std\_logic &  \\
			veto  &  & std\_logic &  \\
			\hline
			ASIC\_in                & \multirow{7}{*}[-28.75pt]{Out}
			                           & std\_logic                & Fast serial commands to the ASIC.  \\
			clk\_in                 &  & std\_logic                & Clock to the ASIC.  \\
			readout\_sent           &  & std\_logic                & Readout flag (for ASIC receiver block).  \\
			rsync\_sent             &  & std\_logic                & RSYNC flag (for slow control block).  \\
			downscaler\_start\_sent &  & std\_logic                & Downscaler start flag.  \\
			downscaler\_stop\_sent  &  & std\_logic                & Downscaler stop flag.  \\
			start\_nwords\_o        &  & std\_logic\_vector (31:0) & Number of words used for `START' to set veto\_start delay.\\
			\hline
			bram\_rdma & \multirow{2}{*}[-17.25pt]{Interface} & RDMA & Interface to the ASIC command word BRAM. Mask: 0x000003FF. \\
			ctrl\_rdma &                            & RDMA & Interface to the control register. Mask: 0x0000000F. \\
		\end{tabulary}
		\end{center}
		\caption{Interface for the transmitter block}
		\label{tab:tx_interface}
	\end{table}
	
	% subsection tx_interface (end)
	\subsection{Registers} % (fold)
	\label{sub:tx_registers}
	
	% subsection tx_registers (end)
	\subsection{Implementation} % (fold)
	\label{sub:tx_implementation}
	\begin{table}
		\begin{center}
			\setlength{\extrarowheight}{1.5pt}
			\begin{tabular}{c | l}
				Word & Name \\
				\hline	
				0x00 & NOP \\
				0x01 & STAND\_BY \\
				0x02 & POWER\_UP \\
				0x03 & ON\_CHIP\_RESET\_DISABLE \\
				0x04 & ON\_CHIP\_RESET\_ENABLE \\
				0x05 & RESET\_PRE\_AMP \\
				0x06 & RESET\_GAIN\_FRONT \\
				0x07 & RESET\_GAIN\_BACK \\
				0x08 & Reserved \\
				0x09 & TEST\_MODE\_D \\
				0x0A & TUNE\_MODE \\
				0x0B & CLEAR\_SKIP\_REGISTER \\
				0x0C & RESET\_WRITE\_POINTER \\
				0x0D & RESET\_TRIGGER\_POINTER \\
				0x0E & START\_WRITE\_POINTER \\
				0x0F & START\_TRIGGER\_POINTER \\
				0x10 & TRIGGER\_FLAG\_SET \\
				0x11 & READ\_OUT\_DATA \\
				0x12 & REMOVE\_RESET\_PRE\_AMP \\
				0x13 & REMOVE\_RESET\_GAIN\_STAGE1 \\
				0x14 & REMOVE\_RESET\_GAIN\_STAGE2 \\
				0x15 & CLOCK\_DIV\_SEL \\
				0x16 & SELF\_TEST\_EN \\
				0x17 & STOP\_READ\_OUT \\
				0x18 & RESET\_STATE\_MACHINE \\
				0x5A5A5 & SYNC\_RESET \\
			\end{tabular}
		\end{center}
		\caption{ASIC command words, see \cite{REF FOR LPD ASIC} for a full description and recommended use of these commands.}
		\label{tab:asic_command_words}
	\end{table}

	
	% subsection tx_implementation (end)
	% section transmitter (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\appendix
	\section{RDMA interface} % (fold)
	\label{sec:rdma_interface}
	The RDMA interfaces~\cite{RDMA INTERFACE} used throughout the project have the interface seen in table~\ref{tab:rdma_interface}. The appropriate mask for the address is given in appropriate interface notes. In general for BRAMs a size of 32\(\times\)1024 the appropriate bits are 9:0 whilst for registers the bits 3:0 are used. 
		
		\begin{table}
			\begin{center}
			\begin{tabulary}{\textwidth}{l|c|c|L}
				Name & Direction & Type & Notes \\
				\hline
				clk       & \multirow{6}{*}{in}
					  		    & std\_logic                & The RDMA clock (this can be separate from e.g. the CCC clock).\\
				rst       &     & std\_logic                & Reset the memory to some default state.                       \\
				rd\_en    &     & std\_logic                & Enable read operations at the address.                        \\
				wr\_en    &     & std\_logic                & Enable write operations at the address.                       \\
				addr      &     & std\_logic\_vector (31:0) & The address the MSB will be masked.                           \\
				data\_in  &     & std\_logic\_vector (31:0) & Used for writing and otherwise ignored.                       \\
				\hline
				data\_out & out & std\_logic\_vector (31:0) & Data out, only guaranteed for read operations.                \\
				
			\end{tabulary}
			\end{center}
			\caption{Standard RDMA interface.}
			\label{tab:rdma_interface}
		\end{table}
	% section rdma_interface (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\section{Local Link interface} % (fold)
	\label{sec:local_link_interface}
	The Local Link~\cite{LOCAL LINK CITATION} interface is used only to read out the veto log. The details of the frame composition are given in section~\ref{sec:veto_filter}. The interface used is minimal (i.e. no optional features are used) and given in table~
	\begin{table}
		\begin{center}
		\begin{tabulary}{\textwidth}{l | c | c | L}
			Name & Direction & Type & Notes \\
			\hline
				clk        & \multirow{3}{*}{in} 
					 			 & std\_logic                 & The LL clock (this can be separate from e.g. the CCC clock).\\
				rst        &     & std\_logic                 & Abort.                                                      \\
				dst\_rdy   &     & std\_logic                 & Destination ready.                                          \\
				\hline
				src\_rdy   & \multirow{4}{*}{out}
				                 & std\_logic                 & Source ready i.e. this block.                               \\
				sof        &     & std\_logic                 & Start of frame flag.                                        \\
				eof        &     & std\_logic                 & End of frame flag.                                          \\
				data\_out  &     & std\_logic\_vector (255:0) & Data out.                                                   \\
		\end{tabulary}
		\end{center}
		\caption{Minimal local link interface as used by the veto logger.}
		\label{tab:local_link_interface}
	\end{table}
	
	% section local_link_interface (end)
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\bibliographystyle{plain}
	\bibliography{}
\end{document}
		